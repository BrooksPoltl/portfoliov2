{"componentChunkName":"component---src-templates-blog-post-js","path":"/articles/teachyourselfcs/programming/03:data-driven-programming/","result":{"data":{"site":{"siteMetadata":{"title":"Brooks Poltl"}},"markdownRemark":{"id":"f384d3af-5909-5c25-a02f-176fb86a1b1e","excerpt":"LECTURES L14 2 types of expressions: Above is the eval function for an interpreter in Scheme. Notice it attempts to determine the type of expression then has aâ€¦","html":"<h4>LECTURES</h4>\n<h5>L14</h5>\n<p>2 types of expressions:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                 expr\n    _______________|___________________    \n    |                                 |\n    atomic                           list\n    ___|__________                     |\n    |            |            _______________________       \nself-eval    variables        procedures special-forms</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    (define (eval exp)\n    (cond ((self-evaluating? exp) exp)\n    ((symbol? exp) (look-up-global-value exp))\n    ((special-form? exp) (do-special-form exp))\n    (else (apply (eval (car exp))\n    (map eval (cdr exp)) ))))</code></pre></div>\n<p>Above is the eval function for an interpreter in Scheme. Notice it attempts to determine the type of expression then has a function to handle them. If it is a list it recursively calls eval to break the list into primitives.\n<br>\n<br></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    (define (apply proc args)\n        (if (primitive? proc)\n            (do-magic proc args)\n            (eval (substitute (body proc) (formals proc) args))))</code></pre></div>\n<p>apply takes a procedure and a list of arguments. In the else of <code class=\"language-text\">eval</code> apply gets the first argument which will always the procedure call, and then it maps the arguments.\n<br>\n<br></p>\n<p>If the procedure is a primitive it gets handled at the machine language level.</p>\n<br>\n<br>\n<p>If the procedure is created by a lambda,\nit has formal parameters and a body.\n<br>\n<br>\nScheme uses environmental model of evaluation, but we are building a substitution model interpreter right now.\nSubstitution works for functional programming, but not all paradigms.\n<br>\n<br></p>\n<h5>L15</h5>\n<p>Why use a scheme interpreter to build a new one?\n<br>\n<br>\nHelps understand model of evaluation\n<br>\nExperiment with modifications to scheme\n<br>\nMost of the original interpreter is written in scheme.\n<br>\nConveys a big concept in cs which is universality.\n<br>\n<br></p>\n<p>universality is the concept of one machine that can run a large breadth of functions.\n<br>\n<br>\nApplicative: argument values\n<br>\nNormal: argument expressions\n<br></p>\n<p>Read: takes the input and turns it into box pointer diagrams.\n<br>\nQuote: takes cadr of the next expression.\n<br></p>\n<h5>L16</h5>\n<p>concepts:\n<br>\ntype tagging\n<br>\ndata directed programming\n<br>\nmessage passing\n<br></p>\n<p>type tagging: car is the symbol, cdr is the arguments.\n<br></p>\n<p>data directed programming: write one operation that does everything.\n<br>\nNot functional programming if you call the same expression and get different results.\n<br></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(get &#39;brian &#39;address)\n; #f\n(put &#39;brian &#39;address &#39;(781 Soda))\n; ok\n(get &#39;brian &#39;address)\n; (781 soda)</code></pre></div>\n<br>\n<br>\n<p>This is not functional because same expression returns different results.\nYou can still use these in a functional way by assigning at the beginning and never reassigning.\n<br></p>\n<h5>L17</h5>\n<p>Horizontal slices through the table: messaging. The name of the interface knows all the function.</p>\n<br>\n<p>Horizontal slicing good for making prototypes.</p>\n<br>\n<p>4 kinds of numbers:\n<br>\ninteger\n<br>\nrational\n<br>\nreal\n<br>\ncomplex\n<br>\n<br>\nregular people: 1 operand = unary, 2 operands = binary\n<br>\n<br>\nprogrammers: 1 operand = monadic, 2 operands = dyadic\n<br>\n<br></p>\n<h5>L38</h5>\n<h5>L39</h5>\n<h4>LAB</h4>\n<h5>lab 3</h5>\n<h4>READINGS</h4>\n<h5>2.4</h5>\n<h5>2.5</h5>","frontmatter":{"title":"03: Data Driven Programming","date":"May 03, 2020","description":"Part 3 of CS61A Structure and Interpretation of Computer Programs","subCat":"programming"}}},"pageContext":{"slug":"/03:data-driven-programming/","previous":{"fields":{"slug":"/02:building-abstractions-with-data/"},"frontmatter":{"title":"02: Building Abstractions With Data","topic":"teachyourselfcs","subCat":"programming"}},"next":null}}}