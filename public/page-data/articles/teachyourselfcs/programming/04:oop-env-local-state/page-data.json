{"componentChunkName":"component---src-templates-blog-post-js","path":"/articles/teachyourselfcs/programming/04:oop-env-local-state/","result":{"data":{"site":{"siteMetadata":{"title":"Brooks Poltl"}},"markdownRemark":{"id":"6117f539-b890-5ff2-85f5-421e6ed5d6bd","excerpt":"This article is a part of a series where I go through teachyourselfcs.\nIf you would like to start at the beginning start here. LECTURES L18 OOP is a…","html":"<p>This article is a part of a series where I go through <a href=\"https://teachyourselfcs.com/\">teachyourselfcs</a>.\nIf you would like to start at the beginning start <a href=\"https://bpp.dev/articles/teachyourselfcs/programming/00:getting-started/\">here</a>.</p>\n<h4>LECTURES</h4>\n<h5>L18</h5>\n<p>OOP is a implementation of lambda.\n<br>\n<br></p>\n<p>class\n<br>\ninstance\n<br>\ninstantiation variable\n<br>\nclause\n<br>\nmethod\n<br>\ninstance-vars\n<br>\nClass variables\n<br>\n<br></p>\n<p>Anytime you change the value of something use a exclamation point to signify you are not doing functional programming.</p>\n<h5>L19</h5>\n<p>OOP implements inheritance through delegation (assigning to something else).\n<br>\n<br>\nChild looks for the methods and if it can’t find it the message is sent to the parent.\n<br>\n<br>\ndefault-method: what to do when the parent can’t handle the message.\n<br>\n<br>\ninitialize: method only used once to setup the class\n<br>\n<br>\ndispatch procedure: takes message and returns a method.</p>\n<h5>L20</h5>\n<p>OOP: With every object you have the procedures that work on it.\n<br>\n<br></p>\n<p>Polymorphism: Ability to work with other types in the sending op messages.\n<br>\n<br></p>\n<p>Garbage collection: automatic storage management.</p>\n<br>\n<h5>L21</h5>\n<p>global variables: available to anyone\n<br>\nclass variables: available to that class\n<br>\ninstance variables available to that instance\n<br></p>\n<p>Persistent local state variables.\nLambda inside a let creates local state variables.\n<br>\n<br></p>\n<p>Can wrap lambda in parenthesis to invoke it after creating it.</p>\n<br>\n<br>\n<p>Substitution model (eval exp):\n<br>\nEval all sub expressions\n<br>\napply procedure to arg list\n<br>\nsubstitute args for params in body\n<br>\neval modified body\n<br>\n<br></p>\n<p>Environment model (eval exp in env):\n<br>\nEval all sub expressions.\n<br>\napply procedure to arg list\n<br>\nmake an env with params bound to args\n<br>\nEval body in new env.\n<br></p>\n<h5>L22</h5>\n<p>Environemnt:\n<br>\nframe\n<br>\nmaps variables to values\n<br>\npointer to “enclosing environment”\n<br>\nAll evals are done in a environment.\n<br>\n<br></p>\n<p>Creates a new environment when you invoke a procedure.\n<br></p>\n<p>Can create a pointer to another environment to inherit those variables.\n<br>\n<br>\n1.) look in current env, if found return value\n<br>\n2.) look in parent env, if found return value\n<br>\n3.) if not in parent env returne UNBOUND VARIABLE error.</p>\n<p>Lexical scoping: extends lambda environment\n<br></p>\n<p>dynamic scope: extends specific environments.\n<br></p>\n<h5>L23</h5>\n<p>Professor out, more review on environments.\n<br></p>\n<h4>LABS</h4>\n<h5>4A</h5>\n<p>4A doesn’t have code problems.</p>\n<h5>4B</h5>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(define (make-account init-amount)\n(let ((balance init-amount) (transactions &#39;()))\n    (define (withdraw amount)\n        (set! transactions (append transactions (list &#39;withdraw amount)))\n        (set! balance (- balance amount)) balance)\n    (define (deposit amount)\n        (set! transactions (append transactions (list &#39;deposit amount)))\n        (set! balance (+ balance amount)) balance)\n    (define (dispatch msg)\n        (cond \n            ((eq? msg &#39;withdraw) withdraw)\n            ((eq? msg &#39;deposit) deposit)\n            ((eq? msg &#39;balance) balance)\n            ((eq? msg &#39;transactions) transactions)))\n        dispatch))</code></pre></div>\n<h4>READINGS</h4>\n<h5>3.1 Assignment and local state</h5>\n<p>Delayed evaluation: decoupling time from events during evaluation.\n<br>\n<br>\nAssignment operator: allows the ability to change the value associated with a variable.\n<br>\n<br></p>\n<p>set!: exclamation shows reassignment.\n<br>\n<br>\nReassignment makes the substitution model no longer an adequate model, because the substitution model does not keep track of occurences, it uses the first occurence to sustitute in the body.\n<br>\n<br>\nReassignment can make 2 identical function calls have different results. The term for not using reassigment in functions is “referential transparency”.\n<br>\n<br>\nNot having referential transparency means that you are unable to know what an object is without observing its state.\n<br>\n<br></p>\n<p>Programming that makes extensive use of reassignment is considered “imperative programming”.\n<br>\n<br></p>\n<p>This opens up the program to bugs not able to be created in functional programming.</p>\n<h5>3.2 Evironment model of evaluation</h5>\n<p>Environment: a place in which variables are stored.\n<br>\n<br></p>\n<p>Environment is a sequence of frames, each frame a table of bindings.\n<br>\n<br></p>\n<p>Each frame points to a parent environment unless it is the global environment.\n<br>\n<br></p>\n<p>When defining a procedure the global env creates a binding tying the name of the procedure to the lambda procedure itself.\n<br>\n<br></p>\n<p>State within a procedure is bound within the frame of the procedure and not the environment of the enclosing procedure.</p>\n<br>","frontmatter":{"title":"04: OOP, Environments, and Local State","date":"May 04, 2020","description":"Part 4 of CS61A Structure and Interpretation of Computer Programs","subCat":"programming"}}},"pageContext":{"slug":"/04:oop-env-local-state/","previous":{"fields":{"slug":"/03:data-driven-programming/"},"frontmatter":{"title":"03: Data Driven Programming","topic":"teachyourselfcs","subCat":"programming"}},"next":null}}}