{"componentChunkName":"component---src-templates-blog-post-js","path":"/articles/teachyourselfcs/programming/07-evaluator-logic/","result":{"data":{"site":{"siteMetadata":{"title":"Brooks Poltl"}},"markdownRemark":{"id":"5bc51e94-6eca-509d-a41e-3d20e59d5030","excerpt":"This article is a part of a series where I go through teachyourselfcs.\nIf you would like to start at the beginning start here. LECTURES L40 Sometimes normal…","html":"<p>This article is a part of a series where I go through <a href=\"https://teachyourselfcs.com/\">teachyourselfcs</a>.\nIf you would like to start at the beginning start <a href=\"https://bpp.dev/articles/teachyourselfcs/programming/00-getting-started/\">here</a>.</p>\n<h4>LECTURES</h4>\n<h5>L40</h5>\n<p>Sometimes normal order is prefferable, you can modify evaluator to use normal order.\n<br>\n<br></p>\n<h5>L41</h5>\n<p>Analyzing evaluator: variant on metacircular evaluator, basically a compiler for scheme into scheme (transpiler like typescript).\n<br>\n<br></p>\n<h5>L42</h5>\n<p>declaritive programming or logic programming: not telling computer sequence of steps. Gives a set of sentences in logical form, to form rules to determine an output.\n<br>\n<br></p>\n<h5>L43</h5>\n<p>Unification: Variables on both sides (bindings), you can use unification to compute anything computable (Turing complete). Popular in database systems.\n<br>\n<br></p>\n<h5>L44</h5>\n<p>Programming Paradigms:\n<br>\nfunctional\n<br>\nobject oriented\n<br>\nclient/server\n<br>\ndeclarative/logic</p>\n<br>\n<br>\n<p>Most programs use multiple paradigms, but are smart in how they implement each (not using concurrency for object oriented task).\n<br>\n<br></p>\n<p>Some languages only functional or OOP, but better for it to be in your head that way you can write programs taking advantage of multiple paradigms.\n<br>\n<br>\nhigh level language: abstracts away the inner workings of the computer\n<br>\nlow level language: exposes parts of the inner workings so you can manipulate the machine.</p>\n<h4>READING</h4>\n<h5>4.1.7</h5>\n<p>Evaluator is inefficient, analyzes syntax multiple times in an expression, it can be made more efficient by creating a procedure that analyzes the syntax and returns a procedure that can be executed.</p>\n<h5>4.2</h5>\n<p>applicative order: all arguments are evaluated when the procedure is applied.\n<br>\n<br></p>\n<p>Normal order: all arguments are evaluated when needed (AKA lazy evaluation).\n<br>\n<br></p>\n<p>These delayed arguments are not evaluated, they are turned into thunks (a procedure that returns a procedure), the thunk is then called whenever the argument is needed.\n<br>\n<br></p>\n<p>Process of evaluating the expression in a thunk is called forcing.</p>\n<h5>4.3</h5>\n<p>Nondeterministic computing: “generate and test”\n<br>\n<br>\ngenerating possibilites, and then filtering those possibilities to the desired result.</p>\n<h5>4.4</h5>\n<p>Most programming langauges are unidirectional (computation with well defined inputs and outputs).\n<br>\n<br>\nUnification: In order to handle rules in a query language you need a generalization of pattern matching since the rules contain variables.</p>","frontmatter":{"title":"07: Evaluator and Logic Programming","date":"August 03, 2020","description":"Part 7 of CS61A Structure and Interpretation of Computer Programs","subCat":"programming"}}},"pageContext":{"slug":"/07-evaluator-logic/","previous":{"fields":{"slug":"/06-concurrency-streams/"},"frontmatter":{"title":"06: Concurrency and Streams","topic":"teachyourselfcs","subCat":"programming"}},"next":{"fields":{"slug":"/08-c-and-number-bases/"},"frontmatter":{"title":"08: C and Number Bases","topic":"teachyourselfcs","subCat":"computer-architecture"}}}}}