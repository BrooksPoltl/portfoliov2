{"expireTime":9007200868482784000,"key":"transformer-remark-markdown-html-743130049fe6640e1889fbad8827d1d0-gatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypants-","val":"<p>This article is a part of a series where I go through <a href=\"https://teachyourselfcs.com/\">teachyourselfcs</a>.\nIf you would like to start at the beginning start <a href=\"https://bpp.dev/articles/teachyourselfcs/programming/00-getting-started/\">here</a>.</p>\n<h4>LECTURES</h4>\n<h5>L1</h5>\n<p>Course concentrates on broad ideas in computer architecture. C is close to underlying hardware.</p>\n<br>\n<br>\n<p>What is the cloud?\n<br>\nThe cloud is a data center of computers in a warehouse. They need to be near a river (to cool the computers) and low power cost. Also need to be in a secret location to avoid malicious attacks. Server can have 12 to 16 processors. Even single core can do many instructions at once. Tons of Logic Gates running in parallel.</p>\n<br>\n<br>\n<p>Abstraction:\n<br></p>\n<p>hiding unnecessary details at the upper level.\n<br>\nMachine level, Assembly level, High level.\n<br>\n<br>\nMoore’s Law:\n<br>\nDesigning through trends.\n<br>\n“Amount of transistors on a chip will double every 2 years”\n<br>\nThis however is changing. They can make them smaller, but it is much more expensive to make them smaller.\n<br>\n<br>\nprinciple of locality (memory hierarchy):\n<br>\nSpeed on the computer dependent on locality.\nFastest memory is the registers. Chip Cache second closest, then Board Cache. Then Memory takes 10 times longer than cache. Disk are really slow (which is why they are gone now).</p>\n<br>\n<br>\n<p>Parallelism:\n<br>\nability to do multiple things at once. Parallelism is limited, performance gain is limited to how much has to be done sequentially.\n<br>\n<br>\nPerformance Measurement &#x26; improvement\n<br>\nFiguring how fast your code goes, and how to improve the performance.\n<br>\n<br>\nDependability via Redundancy\n<br>\nCoping with failures, You have to maintain backups for data stores that way you don’t lose data.\n<br>\n<br>\nbit terminology:\n<br></p>\n<ul>\n<li>8-bit: byte\n<br></li>\n<li>16-bit: half-words</li>\n<li>32-bit: words</li>\n<li>64-bit: double words\n<br>\nInteger and floating-point operations can load to results too big within their representation (overflow/underflow).\n<br>\n<br>\nsigned and unsigned integers:\n<br>\nsigned integers: positive and negative numbers\n<br>\nunsigned integers: positive number\n<br>\n32-bit word: 2**32 binary numbers\n<br>\nunsigned integers in 32 bit word: 4,294,967,295 (4giga)\n<br>\nsigned integers: 1/2 positive, 1/2 negative, 1 0\n<br>\n<br>\nTwo’s complement:\n<br>\nleft most bit shows positive or negative (1 negative, 0 positive).\n<br>\ngo from positive to negative\n<br>\ninvert all bits and add 1</li>\n</ul>\n<h5>L2</h5>\n<p>Compiled vs interpreted languages:\n<br>\n<br>\nHigh level language compiles down to Assembly language, Assembler transfers to machine language.</p>\n<p>C is lowest of high level langauge, also called universal assembler. Low level but not tied to machine.</p>\n<p>C compiles code into specific machine code x86 vs arm.</p>\n<p>.o extension is machine code object files.</p>\n<p>Cannot use machine code in different architecture, must re compile if you want to switch machines.</p>\n<p>Relying on architecture can create problems when porting to different architectures.</p>\n<p>C is function oriented, c++ more object oriented.</p>\n<p>unsigned means no negatives.\n<br>\n<br>\nshort: at least 16 bits</p>\n<p>int: could be 16 but could be larger</p>\n<p>long: greated than 32</p>\n<p>all could be 64 bits\n<br>\n<br>\ndefine runs the same speed as const.\n<br>\n<br>\nfunctions have return type, if you dont need to return a type return void.</p>\n<p>can create struct type that acts like a object.\n<br>\n<br>\npointer variable containing an address, aka a memory location\n<br>\n<br>\n&#x26; is address operator.</p>\n<p>*x is value at address x.</p>\n<p>* called the dereference operator</p>\n<h5>L3</h5>\n<p>Address is a value, uses unsigned numbers.</p>\n<br>\n<p>int *x, means variable x is address of an integer.</p>\n<p>x = &#x26;y, assign the address of y to x.</p>\n<p>dereference operator gets the value of a pointer.</p>\n<br>\n<p>to change value of variable you pass a pointer to a function and increment the pointers value.</p>\n<br>\n<p>void * generic pointer to anything. Can lead to bugs and security issues.</p>\n<p>string is a array of characters or chars</p>\n<p>to increment a pointer for an array you pass a pointer to a pointer. that way you arent operating on the copy.</p>\n<h5>L4</h5>\n<p>in C arrays just point to first value in array.</p>\n<br>\n<p>You cant add 2 pointers, multipy or subtract pointer from integer.</p>\n<br>\n<p>4 regions of address space.\n<br>\nstack\n<br>\nheap\n<br>\nstatic data\n<br>\ncode</p>\n<br>\n<br>\n<p>stack- local variables inside functions. (grows downward)</p>\n<p>heap - space requested for dynamic data, handled with malloc() resizes dynamically. (grows upward)</p>\n<p>static data - variables outside of functions (loaded when program starts)</p>\n<p>code - loaded when program starts\n<br></p>\n<p>stack is last in first out.</p>\n<br>\n<p>heap uses 5 builtin functions</p>\n<ul>\n<li>malloc, allocate block of uninitialized memory</li>\n<li>calloc, allocate block of zeroed memory</li>\n<li>free, free previously allocated block of memory</li>\n<li>cfree, dont use (legacy)</li>\n<li>realloc, change size of previously allocated block</li>\n</ul>\n<br>\n<p>size_t is the size of the bytes in machine.</p>\n<p>calling malloc multiple times in a row doesnt mean they will be continuous in memory.</p>\n<p>free releases the memory you allocated.</p>\n<h4>HW 0</h4>\n<p><a href=\"https://github.com/BrooksPoltl/cs61c/blob/master/hw0/hw0.txt\">https://github.com/BrooksPoltl/cs61c/blob/master/hw0/hw0.txt</a></p>\n<h4>READINGS</h4>\n<h5>2.4</h5>"}