{"expireTime":9007200842935615000,"key":"transformer-remark-markdown-html-1281b1edf2d1ecda695c51ccdb39ed85-gatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypants-","val":"<p>This article is a part of a series where I go through <a href=\"https://teachyourselfcs.com/\">teachyourselfcs</a>.\nIf you would like to start at the beginning start <a href=\"http://localhost:8000/teachyourselfcs/programming/00:getting-started/\">here</a>.</p>\n<h4>LECTURES</h4>\n<h5>User Interface Lectures</h5>\n<p>These lectures are in week 3 of the Calendar, but lecture 5 and 6 for spring 2010 so I’ll just list them here since order doesn’t matter for them.</p>\n<h5>L05</h5>\n<p>This lecture goes over “User interface design” a lecture by Alan Kay. Alan Kay is the inventor of every aspect of the modern computer environment.\n<br>\n<br></p>\n<p>Dynabook was a computer that looks like a calculator.</p>\n<h5>L06</h5>\n<p>This lecture goes over part 2 of “User interface design”. This specific lecture goes over the psychology of UI.</p>\n<h5>L07</h5>\n<h6>Time Efficiency and Order of Growth</h6>\n<p>Measure efficiency by how many constant time expressions are used.\n<br>\n<br></p>\n<p><code class=\"language-text\">se</code> runtime is dependent on how it is used.\n<br>\n<br>\nRange: what does it return.\n<br>\nCalculate runtime for best and worst case scenarios.\n<br>\n<br>\nConstant factors not very valuable in runtime because of Moore’s law. Also as <code class=\"language-text\">n</code> grows constants become less significant.\n<br>\n<br>\nHighest power of <code class=\"language-text\">n</code> is the one that counts.</p>\n<h5>L08</h5>\n<h6>Recursion and Iteration</h6>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">O(1) -------|\nO(log N)----| Searching\nO(N)--------|\n\nO(N log N)--|\nO(N**2) ----| Sorting\n\nO(2 ** N) --|\nO(N!)-------| Intractable\nO(N**N)-----|</code></pre></div>\n<p>Theoretically impossible to do better than O(N log N) for sorting.\n<br>\n<br>\nintractable: You can run them, but with large n they will never stop running.\n<br>\n<br>\nmost of these algorithms have to be approximated to find a viable algorithm.\n<br>\n<br>\nO(N ** 3):\n<br></p>\n<ul>\n<li>matrix multiply</li>\n</ul>\n<h6>space complexity</h6>\n<p>Since a recursive process has to wait for the nested process to finish the space complexity is O(n) for a O(n) runtime procedure.\n<br>\n<br>\nIterative process takes constant time complexity.</p>\n<h5>L09</h5>\n<h6>Data abstraction</h6>\n<p>Abstract data type: doesn’t exist in scheme, created by the programmer.\n<br>\n<br>\nList don’t have to be treated as abstract data type.\n<br>\n<br>\nSentence is a list constrained to only using words.\nBox diagrams:\n<br>\nstart arrow: beginning of diagram\narrows point to box, not item in box.\n<br>\n<br>\nList procedures:\n<br>\ncons: add new element to the front of a list\n<br>\nlist: creates a new list with arguments as items.\n<br>\nappend: put together elements of lists.</p>\n<h5>L10</h5>\n<p>Lisp Higher Order Functions:\n<br>\nEvery: computes function on every word in sentence.\nKeep: Returns subset of a predicate if predicate is true.\n<br>\naccumulate: combines things in list/sentence and returns result.\nmap: applies function to each list in nested list.\nfilter:</p>\n<h5>L11</h5>\n<h5>L12</h5>\n<h5>L13</h5>\n<h4>LABS</h4>\n<h5>Lab 2A</h5>\n<h5>Lab 2B</h5>\n<h4>READINGS</h4>\n<h5>2.1</h5>\n<h5>2.2</h5>\n<h5>2.3</h5>"}