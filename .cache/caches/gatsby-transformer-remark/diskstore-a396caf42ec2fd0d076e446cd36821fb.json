{"expireTime":9007200843266846000,"key":"transformer-remark-markdown-html-dc2f106ffcdd8e09eeee17f5a8937706-gatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypants-","val":"<h4>LECTURES</h4>\n<h5>L14</h5>\n<p>2 types of expressions:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                 expr\n    _______________|___________________    \n    |                                 |\n    atomic                           list\n    ___|__________                     |\n    |            |            _______________________       \nself-eval    variables        procedures special-forms</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    (define (eval exp)\n    (cond ((self-evaluating? exp) exp)\n    ((symbol? exp) (look-up-global-value exp))\n    ((special-form? exp) (do-special-form exp))\n    (else (apply (eval (car exp))\n    (map eval (cdr exp)) ))))</code></pre></div>\n<p>Above is the eval function for an interpreter in Scheme. Notice it attempts to determine the type of expression then has a function to handle them. If it is a list it recursively calls eval to break the list into primitives.\n<br>\n<br></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    (define (apply proc args)\n        (if (primitive? proc)\n            (do-magic proc args)\n            (eval (substitute (body proc) (formals proc) args))))</code></pre></div>\n<p>apply takes a procedure and a list of arguments. In the else of <code class=\"language-text\">eval</code> apply gets the first argument which will always the procedure call, and then it maps the arguments.\n<br>\n<br></p>\n<p>If the procedure is a primitive it gets handled at the machine language level.</p>\n<br>\n<br>\n<p>If the procedure is created by a lambda,\nit has formal parameters and a body.\n<br>\n<br>\nScheme uses environmental model of evaluation, but we are building a substitution model interpreter right now.\nSubstitution works for functional programming, but not all paradigms.\n<br>\n<br></p>\n<h5>L15</h5>\n<p>Why use a scheme interpreter to build a new one?\n<br>\n<br>\nHelps understand model of evaluation\n<br>\nExperiment with modifications to scheme\n<br>\nMost of the original interpreter is written in scheme.\n<br>\nConveys a big concept in cs which is universality.\n<br>\n<br></p>\n<p>universality is the concept of one machine that can run a large breadth of functions.\n<br>\n<br>\nApplicative: argument values\n<br>\nNormal: argument expressions\n<br></p>\n<p>Read: takes the input and turns it into box pointer diagrams.\n<br>\nQuote: takes cadr of the next expression.\n<br></p>\n<h5>L16</h5>\n<p>concepts:\n<br>\ntype tagging\n<br>\ndata directed programming\n<br>\nmessage passing\n<br></p>\n<p>type tagging: car is the symbol, cdr is the arguments.\n<br></p>\n<p>data directed programming: write one operation that does everything.\n<br>\nNot functional programming if you call the same expression and get different results.\n<br></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(get &#39;brian &#39;address)\n; #f\n(put &#39;brian &#39;address &#39;(781 Soda))\n; ok\n(get &#39;brian &#39;address)\n; (781 soda)</code></pre></div>\n<br>\n<br>\n<p>This is not functional because same expression returns different results.\nYou can still use these in a functional way by assigning at the beginning and never reassigning.\n<br></p>\n<h5>L17</h5>\n<p>Horizontal slices through the table: messaging. The name of the interface knows all the function.</p>\n<br>\n<p>Horizontal slicing good for making prototypes.</p>\n<br>\n<p>4 kinds of numbers:\n<br>\ninteger\n<br>\nrational\n<br>\nreal\n<br>\ncomplex\n<br>\n<br>\nregular people: 1 operand = unary, 2 operands = binary\n<br>\n<br>\nprogrammers: 1 operand = monadic, 2 operands = dyadic\n<br>\n<br></p>\n<h4>LAB</h4>\n<h5>lab 3</h5>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(define (count-change amount)\n(cc amount &#39;(50 25 10 5 1)))\n\n(define (cc amount kinds-of-coins)\n    (cond ((= amount 0) 1)\n    ((or (&lt; amount 0) (equal? kinds-of-coins &#39;())) 0)\n    (else (+ (cc amount\n                (cdr kinds-of-coins))\n    (cc (- amount \n    (first-denomination kinds-of-coins))\n    kinds-of-coins)))))\n\n(define (first-denomination kinds-of-coins)\n(car kinds-of-coins))</code></pre></div>\n<p>This modifies the procedure on page 40-41 for count-change.\n<br>\n<br>\nThis replaces the amount of coins with a sentence of coin amounts. I modified it to check for an empty array instead of 0, then when all possibilities of a denomination are checked I switch it to the remaining denominations using <code class=\"language-text\">cdr</code>. Then all I have to do to find the <code class=\"language-text\">first-denomination</code> is return <code class=\"language-text\">car</code> of the list.</p>\n<h4>READINGS</h4>"}