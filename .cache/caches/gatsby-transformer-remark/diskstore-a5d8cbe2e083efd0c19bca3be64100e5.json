{"expireTime":9007200868826044000,"key":"transformer-remark-markdown-html-4007b719043d981fe2b8273805a11d69-gatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypants-","val":"<p>This article is a part of a series where I go through <a href=\"https://teachyourselfcs.com/\">teachyourselfcs</a>.\nIf you would like to start at the beginning start <a href=\"https://bpp.dev/articles/teachyourselfcs/programming/00-getting-started/\">here</a>.</p>\n<h2>LECTURES</h2>\n<h3>L5</h3>\n<p>Assembly language below high level language (MIPS)\n<br>\nAssebler turns assembly code into machine code\n<br>\njob of cpu: execute lost of instructions (primitive operations that the cpu can execute)\n<br>\nExample instruction set architectures:\n<br></p>\n<ul>\n<li>ARM</li>\n<li>x86</li>\n<li>mips</li>\n<li>risc-v</li>\n<li>ibm/motorola powerPC</li>\n<li>intel IA64</li>\n</ul>\n<br>\n<p>Assembly Variables: Registers\n<br>\nsince registers are in hardware there is a limited number, 32 registers in MIPS</p>\n<br>\n<p>32 bits in a register, groups of 32 bits called a word in mips.</p>\n<p>Number refererences: ($0, $1, $2)</p>\n<p>or</p>\n<p>name references: ($s0-$s7, $t0-\\$t7) c variables and temporary variables (preffered because easier to debug)</p>\n<br>\n<p>add in assembly\n<br>\n<code class=\"language-text\">add $s0, $s1, $s2</code> = <code class=\"language-text\">a = b + c</code>\n<br></p>\n<p>subtract in assembly\n<br>\n<code class=\"language-text\">sub $s3, $s4, $s5</code> = <code class=\"language-text\">d = e - f</code>\n<br></p>\n<p>how to do a = b + c + d - e</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  add $t0, $s1, $s2 # temp = b + c\n  add $t0, $t0, $s3 # temp = temp + d\n  sub $s0, $t0, $s4 # a = temp - e</code></pre></div>\n<br>\n<p>Immediates:\n<br>\nImmediates are numerical constants, they appear often in code, so there are special instructions for them.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  addi $s0, $s1, -10 #mips\n  f =  g - 10 #c</code></pre></div>\n<p>you have a special register for zero cases</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  add $s0, $s1, $zero #mips\n  f = g #c</code></pre></div>\n<p>Overflow handling in mips:\n<br>\nDetect overflow:</p>\n<ul>\n<li>add</li>\n<li>add immediate</li>\n<li>subtract</li>\n</ul>\n<p>do not detect overflow:</p>\n<ul>\n<li>add unsigned</li>\n<li>add immediate unsigned</li>\n<li>subtract unsigned</li>\n</ul>\n<br>\n<p>only 32 registers, if you dont have space in registers you have to go to memory.\n<br></p>\n<p>transfer from memory to register:</p>\n<p>C code:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  int A[100];\n  g = h + A[3];</code></pre></div>\n<p>mips:</p>\n<p>lw = load word</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  lw $t0, 12 ($s3) #Temp reg $t0 gets A[3]\n  add $s1, $s2, $t0 # g = h + A[3]</code></pre></div>\n<br>\n<p>s3 is a pointer to the beginning of the A array</p>\n<p>offset is 12 (offset is in bytes) so it fast fowards 12 bytes in array or 96 bits 96/32 = 3 (32 is size of int) , have to increment base by the size of the datatype.</p>\n<br>\n<p>transfer from register to memory:</p>\n<p>C code:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  int A[100];\n  A[10] = h + A[3];</code></pre></div>\n<p>mips:\nsw = store word</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  lw $t0, 12 ($s3) #Temp reg $t0 gets A[3]\n  add $t0, $s2, $t0 # temp reg $t0 gets h + A[3]\n  sw $t0, 40 ($s3) # A[10] = h + A[3]</code></pre></div>\n<br>\n<p>In addition to word data transfers\nmips has byte data transfers:</p>\n<p>-load byte: lb\n-store byte: sb</p>\n<p>same format as lw, sw</p>\n<p>lbu for unsigned.</p>\n<br>\n<p>speed of registers vs. memory</p>\n<p>smaller is faster with registers.\nregisters are 100-500 times faster than memory.</p>\n<p>mips if statement:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  beq register1, register2, L1</code></pre></div>\n<p>means: go to statement L1 if value in register1 == value in register2</p>\n<p>otherwise got to next statement</p>\n<p>beq = branch if equal</p>\n<br>\n<p>branch - change of control flow</p>\n<p>conditional branch - change control flow depending on outcome of comparison</p>\n<br>\n<p>branch if equal (beq) or branch if not equal (bne)</p>\n<br>\n<p>unconditional branch - always branch</p>\n<p>jump (j)</p>\n<h3>L6</h3>\n<p>Machine code is lowest level of software.</p>\n<p>words and vocabulary are called instructions and instruction sets respectively</p>\n<p>mips is example RISC instruction set</p>\n<p>rigid format 1 operation, 2 operands, 1 destination</p>\n<p>example operations:</p>\n<ul>\n<li>add</li>\n<li>sub</li>\n<li>mul</li>\n<li>div</li>\n<li>and</li>\n<li>or</li>\n<li>sll</li>\n<li>srl</li>\n<li>sra</li>\n</ul>\n<p>operations to move data around registers and memory:</p>\n<ul>\n<li>lw</li>\n<li>sw</li>\n<li>lb</li>\n<li>sb</li>\n</ul>\n<p>operations for decision/ flow control:</p>\n<ul>\n<li>beq</li>\n<li>bne</li>\n<li>j</li>\n<li>slt</li>\n<li>slti</li>\n</ul>\n<p>program is stored as a bunch of bytes</p>\n<p>mips instruction 32 bits or 4 bytes</p>\n<p>Assembler converts assembly to machine code.</p>\n<p>assembly code has .S extension machine code object has .o extension</p>\n<p>machine code executable file has a .out extension</p>\n<br>\n<p>if a branch is false you go to next instruction else you jump to the given instruction (conditional branch).</p>\n<p>unconditional branch: Always go to the “label”</p>\n<br>\n<p>C code</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  if (i == j)\n    f = g + h;</code></pre></div>\n<p>mips code</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  bne $s3, $s4, Exit # notice this is not equal, if false this goes to next line which is add\n  add $s0, $s1, $s2</code></pre></div>\n<br>\n<p>C code</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">if (i == j)\n  f = g + h;\nelse\n  f = g - h;</code></pre></div>\n<p>mips code</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  bne $s3, $s4, Else\n  add $s0, $s1, $s2\n  j Exit\n  Else: sub $s0, $s1, $s2\n  Exit:</code></pre></div>\n<br>\n<p>The jump is needed to jump over the else code, and go to whatever the next line of code is.</p>\n<p>interpreted: compiled at run time, so as a line of code is being executed it compiles to assembly.</p>\n<br>\n<p>C code</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  if (g &lt; h)\n    goto Less;</code></pre></div>\n<p>mips code</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  slt $t0, $s0, $s1\n  bne $t0, $zero, Less</code></pre></div>\n<br>\n<p>slt = set on less than</p>\n<p>set means change to 1.</p>\n<p>reset means change to 0.</p>\n<p>sltu = treats registers as unsigned</p>\n<p>slti = immediates</p>\n<br>\n<p>Six Fundamental Steps in Calling a Function:</p>\n<ol>\n<li>Put parameters in a place where function can access them</li>\n<li>Transfer control to function</li>\n<li>Acquire (local) storage resources needed for function</li>\n<li>Perform desired task of the function</li>\n<li>Put result value in a place where calling code can access it and restore any registers you used</li>\n<li>Return control to point of origin since a function can be called from several points in a program.</li>\n</ol>\n<p>Function call conventions</p>\n<ul>\n<li>Registers faster than memory, so use them</li>\n<li>$a0 - $a3: four argument registers to pass parameters</li>\n<li>$v0-$v1: two value registers to return values</li>\n<li>$ra: one return address register to return to the point of origin</li>\n</ul>\n<p>C code</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  int sum (int x, int y) {\n    return x + y;\n  }</code></pre></div>\n<p>mips code</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  address (shown in decimal)\n  1000 add $a0, $s0, $zero          # x = a\n  1004 add $a1, $s1, $zero          # y = b\n  1008 addi $ra, $zero, 1016        # $ra = 1016\n  1012 j sum                        # jump to sum\n  2000 sum: add $v0, $a0, $a1\n  2004 jr $ra #new instruction</code></pre></div>\n<p>jal = jump and link</p>\n<p>laj = link and jump</p>\n<p>link = form an address or link that points to calling site to allow function to return to\nproper address.</p>\n<p>jr = jump register</p>\n<p>$sp = stack pointer</p>\n<p>Where are old register values saved to restore them after function call?</p>\n<p>ideally they are in the stack.</p>\n<br>\n<p>push: placing data onto stack</p>\n<p>pop: removing data from stack</p>\n<p>stack in memory so need register to point to it ($sp register 29 in mips)</p>\n<p>when adding $sp decrements to add more space</p>\n<p>when removing $sp increases to decrease space.</p>\n<br>\n<p>C code</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  int leaf_example (int g, int h, int i, int j)\n  {\n    int f;\n    f = (g + h) - (i + j);\n    return f;\n  }</code></pre></div>\n<p>paramerter variables g,h,i,j in $a0, $a1, $a2, $a3</p>\n<p>f in $s0</p>\n<p>1 temp register $t0</p>\n<br>\n<p>mips code</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  addi $sp, $sp, -8      # adjust stack for 2 items\n  sw $t0, 4($sp)         # save $t0\n  sw $s0, 0($sp)         # save $s0\n\n  add $s0, $a0, $a1      # f = g + h\n  add $t0, $a2, $a3      # t0 = i + j\n  sub $v0, $s0, $t0      # return value (g+h)-(i+j)\n\n  lw $s0, 0($sp)         # restore register $s0 for caller\n  lw $t0, 4($sp)         # restore register $t0 for caller\n  addi $sp, $sp, 8       # adjust stack to delete 2 items\n  jr $ra                 #jump back to calling routine</code></pre></div>\n<br>\n<p>What if function calls another function?</p>\n<p>have to save the outer functions return address so the inner function can return there.</p>\n<br>\n<p>in C there are 3 import memory areas:</p>\n<ul>\n<li>static</li>\n<li>heap</li>\n<li>stack</li>\n</ul>\n<br>\n<p>mips divides registers into 2 categories:</p>\n<ol>\n<li>Preserved across function call ($ra, $sp, $gp, $fp, “saved registers” $s0-$s7)</li>\n<li>Not preserved ($v0, $v1), argument registers $a0-$a3, temp $t0-$t9</li>\n</ol>\n<p>c has 2 storage classes:</p>\n<p>automatic: variables are local to function and discarded\nstaic: variables exist across exits from and entries to procedures</p>\n<br>\n<p>use stack for automatic (local) variables that dont fit registers</p>\n<br>\n<p>procedure frame or activation record: segment of stack with saved registers and local variables.</p>\n<h3>L7</h3>\n<h3>L8</h3>\n<h2>LABS</h2>\n<h3>LAB 2</h3>\n<h3>LAB 3</h3>\n<h3>HW 1</h3>\n<h3>HW 2</h3>\n<h3>READINGS</h3>\n<h4>2.1</h4>\n<h3>2.2</h3>\n<h3>2.3</h3>\n<h3>2.5</h3>\n<h3>2.6</h3>\n<h3>2.7</h3>\n<h3>2.8</h3>\n<h3>2.9</h3>\n<h3>2.10</h3>\n<h3>2.12</h3>\n<h3>A.1-A.4</h3>\n<h3>A.6</h3>"}