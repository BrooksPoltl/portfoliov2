{"expireTime":9007200844675799000,"key":"transformer-remark-markdown-html-b52e1a6381270ba51472793189089357-gatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypants-","val":"<p>This article is a part of a series where I go through <a href=\"https://teachyourselfcs.com/\">teachyourselfcs</a>.\nIf you would like to start at the beginning start <a href=\"https://bpp.dev/articles/teachyourselfcs/programming/00:getting-started/\">here</a>.</p>\n<h4>LECTURES</h4>\n<h5>L30</h5>\n<p>Client/Server programming\n<br>\n<br></p>\n<p>Have a host, connects with the “internet address”.\nThen you also have a port on that host to connect to.</p>\n<br>\n<br>\n<p>Running out of internet addresses (4 bil), not because of 4 bil computers buts because of unassigned addresses.\n<br>\n<br></p>\n<p>To solve this ipv6 was created.\n<br>\n<br></p>\n<p>https: secure http\n<br>\n<br></p>\n<p>socket is an abstract datatype: 2 way internet connection.\n<br>\n<br></p>\n<p>three way handshake: client sends to server, server sends to client, client sends back to server.\n<br>\n<br></p>\n<h5>L31</h5>\n<p>Your processer has memory inside of it to do computations with data very fast (ram). If second load called before first store happens you can get a concurrency issue.\n<br>\n<br></p>\n<p>Have to “lock out” the variable while it is being used.\n<br>\n<br>\nSerializer: takes a procedure and returns a protected procedure.\nPrevents procedures from overlapping.\n<br>\n<br></p>\n<p>Better to crash than to get wrong answer, because wrong answers pile up without you noticing them.\n<br>\n<br></p>\n<p>Inefficiency: not using parrallelism at all\n<br>\n<br>\nDeadlock: 2 threads locked waiting for eachother to finish\n<br>\n<br></p>\n<p>unfairness: process A wins and process B can’t win.</p>\n<h5>L32</h5>\n<p>Correct answer. Consistent within sequential order of the evaluated threads.\nSame answer as no parallelism.\n<br>\n<br></p>\n<p>serial: one after the other\n<br>\n<br></p>\n<p>Most programs aren’t programmed with deadlock in mind, because processes are very fast.\n<br>\n<br></p>\n<p>Figure out about the deadlock from thread maintenance in the database, then you kill one of the threads.\n<br>\n<br></p>\n<p>Resource starvation: several threads want resource. One thread keeps getting the resource.</p>\n<h5>L33</h5>\n<h5>L34</h5>\n<h5>L35</h5>\n<h5>L38</h5>\n<h5>L39</h5>\n<h4>LABS</h4>\n<h5>LAB 6B</h5>\n<p>(lab 6A is related to logo project).</p>\n<h4>READING</h4>\n<h5>3.4</h5>\n<h5>3.5</h5>"}