{"expireTime":9007200869000346000,"key":"transformer-remark-markdown-html-3315f49654457c4129ad478b98eda2c8-gatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypants-","val":"<p>This article is a part of a series where I go through <a href=\"https://teachyourselfcs.com/\">teachyourselfcs</a>.\nIf you would like to start at the beginning start <a href=\"https://bpp.dev/articles/teachyourselfcs/programming/00-getting-started/\">here</a>.</p>\n<h2>LECTURES</h2>\n<h3>L18</h3>\n<p>OOP is a implementation of lambda.\n<br>\n<br></p>\n<p>class\n<br>\ninstance\n<br>\ninstantiation variable\n<br>\nclause\n<br>\nmethod\n<br>\ninstance-vars\n<br>\nClass variables\n<br>\n<br></p>\n<p>Anytime you change the value of something use a exclamation point to signify you are not doing functional programming.</p>\n<h3>L19</h3>\n<p>OOP implements inheritance through delegation (assigning to something else).\n<br>\n<br>\nChild looks for the methods and if it can’t find it the message is sent to the parent.\n<br>\n<br>\ndefault-method: what to do when the parent can’t handle the message.\n<br>\n<br>\ninitialize: method only used once to setup the class\n<br>\n<br>\ndispatch procedure: takes message and returns a method.</p>\n<h3>L20</h3>\n<p>OOP: With every object you have the procedures that work on it.\n<br>\n<br></p>\n<p>Polymorphism: Ability to work with other types in the sending op messages.\n<br>\n<br></p>\n<p>Garbage collection: automatic storage management.</p>\n<br>\n<h3>L21</h3>\n<p>global variables: available to anyone\n<br>\nclass variables: available to that class\n<br>\ninstance variables available to that instance\n<br></p>\n<p>Persistent local state variables.\nLambda inside a let creates local state variables.\n<br>\n<br></p>\n<p>Can wrap lambda in parenthesis to invoke it after creating it.</p>\n<br>\n<br>\n<p>Substitution model (eval exp):\n<br>\nEval all sub expressions\n<br>\napply procedure to arg list\n<br>\nsubstitute args for params in body\n<br>\neval modified body\n<br>\n<br></p>\n<p>Environment model (eval exp in env):\n<br>\nEval all sub expressions.\n<br>\napply procedure to arg list\n<br>\nmake an env with params bound to args\n<br>\nEval body in new env.\n<br></p>\n<h3>L22</h3>\n<p>Environemnt:\n<br>\nframe\n<br>\nmaps variables to values\n<br>\npointer to “enclosing environment”\n<br>\nAll evals are done in a environment.\n<br>\n<br></p>\n<p>Creates a new environment when you invoke a procedure.\n<br></p>\n<p>Can create a pointer to another environment to inherit those variables.\n<br>\n<br>\n1.) look in current env, if found return value\n<br>\n2.) look in parent env, if found return value\n<br>\n3.) if not in parent env returne UNBOUND VARIABLE error.</p>\n<p>Lexical scoping: extends lambda environment\n<br></p>\n<p>dynamic scope: extends specific environments.\n<br></p>\n<h3>L23</h3>\n<p>Professor out, more review on environments.\n<br></p>\n<h2>LABS</h2>\n<h3>4A</h3>\n<p>4A doesn’t have code problems.</p>\n<h3>4B</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(define (make-account init-amount)\n(let ((balance init-amount) (transactions &#39;()))\n    (define (withdraw amount)\n        (set! transactions (append transactions (list &#39;withdraw amount)))\n        (set! balance (- balance amount)) balance)\n    (define (deposit amount)\n        (set! transactions (append transactions (list &#39;deposit amount)))\n        (set! balance (+ balance amount)) balance)\n    (define (dispatch msg)\n        (cond\n            ((eq? msg &#39;withdraw) withdraw)\n            ((eq? msg &#39;deposit) deposit)\n            ((eq? msg &#39;balance) balance)\n            ((eq? msg &#39;transactions) transactions)))\n        dispatch))</code></pre></div>\n<h2>READINGS</h2>\n<h3>3.1 Assignment and local state</h3>\n<p>Delayed evaluation: decoupling time from events during evaluation.\n<br>\n<br>\nAssignment operator: allows the ability to change the value associated with a variable.\n<br>\n<br></p>\n<p>set!: exclamation shows reassignment.\n<br>\n<br>\nReassignment makes the substitution model no longer an adequate model, because the substitution model does not keep track of occurences, it uses the first occurence to sustitute in the body.\n<br>\n<br>\nReassignment can make 2 identical function calls have different results. The term for not using reassigment in functions is “referential transparency”.\n<br>\n<br>\nNot having referential transparency means that you are unable to know what an object is without observing its state.\n<br>\n<br></p>\n<p>Programming that makes extensive use of reassignment is considered “imperative programming”.\n<br>\n<br></p>\n<p>This opens up the program to bugs not able to be created in functional programming.</p>\n<h3>3.2 Evironment model of evaluation</h3>\n<p>Environment: a place in which variables are stored.\n<br>\n<br></p>\n<p>Environment is a sequence of frames, each frame a table of bindings.\n<br>\n<br></p>\n<p>Each frame points to a parent environment unless it is the global environment.\n<br>\n<br></p>\n<p>When defining a procedure the global env creates a binding tying the name of the procedure to the lambda procedure itself.\n<br>\n<br></p>\n<p>State within a procedure is bound within the frame of the procedure and not the environment of the enclosing procedure.</p>\n<br>"}