{"expireTime":9007200843070225000,"key":"transformer-remark-markdown-html-81eb09ea577e3323af689b4f683ff14d-gatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypants-","val":"<p>This article is a part of a series where I go through <a href=\"https://teachyourselfcs.com/\">teachyourselfcs</a>.\nIf you would like to start at the beginning start <a href=\"http://localhost:8000/teachyourselfcs/programming/00:getting-started/\">here</a>.</p>\n<h4>LECTURES</h4>\n<h5>User Interface Lectures</h5>\n<p>These lectures are in week 3 of the Calendar, but lecture 5 and 6 for spring 2010 so I’ll just list them here since order doesn’t matter for them.</p>\n<h5>L05</h5>\n<p>This lecture goes over “User interface design” a lecture by Alan Kay. Alan Kay is the inventor of every aspect of the modern computer environment.\n<br>\n<br></p>\n<p>Dynabook was a computer that looks like a calculator.</p>\n<h5>L06</h5>\n<p>This lecture goes over part 2 of “User interface design”. This specific lecture goes over the psychology of UI.</p>\n<h5>L07</h5>\n<h6>Time Efficiency and Order of Growth</h6>\n<p>Measure efficiency by how many constant time expressions are used.\n<br>\n<br></p>\n<p><code class=\"language-text\">se</code> runtime is dependent on how it is used.\n<br>\n<br>\nRange: what does it return.\n<br>\nCalculate runtime for best and worst case scenarios.\n<br>\n<br>\nConstant factors not very valuable in runtime because of Moore’s law. Also as <code class=\"language-text\">n</code> grows constants become less significant.\n<br>\n<br>\nHighest power of <code class=\"language-text\">n</code> is the one that counts.</p>\n<h5>L08</h5>\n<h6>Recursion and Iteration</h6>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">O(1) -------|\nO(log N)----| Searching\nO(N)--------|\n\nO(N log N)--|\nO(N**2) ----| Sorting\n\nO(2 ** N) --|\nO(N!)-------| Intractable\nO(N**N)-----|</code></pre></div>\n<p>Theoretically impossible to do better than O(N log N) for sorting.\n<br>\n<br>\nintractable: You can run them, but with large n they will never stop running.\n<br>\n<br>\nmost of these algorithms have to be approximated to find a viable algorithm.\n<br>\n<br>\nO(N ** 3):\n<br></p>\n<ul>\n<li>matrix multiply</li>\n</ul>\n<h6>space complexity</h6>\n<p>Since a recursive process has to wait for the nested process to finish the space complexity is O(n) for a O(n) runtime procedure.\n<br>\n<br>\nIterative process takes constant time complexity.</p>\n<h5>L09</h5>\n<h6>Data abstraction</h6>\n<p>Abstract data type: doesn’t exist in scheme, created by the programmer.\n<br>\n<br>\nList don’t have to be treated as abstract data type.\n<br>\n<br>\nSentence is a list constrained to only using words.\nBox diagrams:\n<br>\nstart arrow: beginning of diagram\narrows point to box, not item in box.\n<br>\n<br>\nList procedures:\n<br>\ncons: add new element to the front of a list\n<br>\nlist: creates a new list with arguments as items.\n<br>\nappend: put together elements of lists.</p>\n<h5>L10</h5>\n<h6>Lisp Higher Order Functions:</h6>\n<p>Every: computes function on every word in sentence.\n<br>\nKeep: Returns subset of a predicate if predicate is true.\n<br>\naccumulate: combines things in list/sentence and returns result.\n<br>\nmap: applies function to each list in nested list, can return list of list still.</p>\n<h5>L11</h5>\n<p>3 pieces to interpreter:\n<br>\nthe read-eval-print loop aka repl (I just learned this is the reason for <a href=\"https://repl.it\">https://repl.it</a>).\nThe last thing in a repl is a call to itself making it infinite.\nexample:\n<br></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(define (calc)\n    (display &quot;calc: &quot;)\n    (flush)\n    (print (calc-eval (read)))\n    (calc))</code></pre></div>\n<p>flush: adds an end of line character\n<br>\n<br>\nScheme has 4 kinds of expressions:\n<br>\nself-evaluating (23 prints 23)\n<br>\nvariables\n<br>\nfunction calls\n<br>\nspecial-forms</p>\n<h5>L12</h5>\n<p>trees: hierarchical data structure\n<br>\n<br>\nbinary search tree: node to left smaller, node to right bigger.\n<br>\n<br>\nparse tree: branch node is operator, leaf nodes are operands\n<br>\n<br>\nleaf node: no children\n<br>\n<br>\nbranch node: node with children\n<br>\n<br>\ndeep list: only the leafs have data.</p>\n<h5>L13</h5>\n<p>Two recursive calls (that run, if it is conditionally running one of two recursive calls it isn’t) in a procedure shows that you are dealing with tree recursion.\n<br>\n<br>\nBreadth first search: when traversing the tree it gets as wide as possible before continuing down the tree.\n<br>\n<br>\nDepth first search: when traversing the tree it gets as deep as possible before continuing. Usually the information is more useful because it list out the parents and children relationships close together.\n<br>\n<br></p>\n<h4>LABS</h4>\n<h5>Lab 2A</h5>\n<h5>Lab 2B</h5>\n<h4>READINGS</h4>\n<h5>2.1</h5>\n<h5>2.2</h5>\n<h5>2.3</h5>"}