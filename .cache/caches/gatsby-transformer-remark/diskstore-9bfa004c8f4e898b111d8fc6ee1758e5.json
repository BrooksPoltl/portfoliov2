{"expireTime":9007200843363574000,"key":"transformer-remark-markdown-html-9e7ed0eb6ec37a421fa7dec21787e242-gatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypants-","val":"<p>This article is a part of a series where I go through <a href=\"https://teachyourselfcs.com/\">teachyourselfcs</a>.\nIf you would like to start at the beginning start <a href=\"https://bpp.dev/articles/teachyourselfcs/programming/00:getting-started/\">here</a>.</p>\n<h4>LECTURES</h4>\n<h5>L18</h5>\n<p>OOP is a implementation of lambda.\n<br>\n<br></p>\n<p>class\n<br>\ninstance\n<br>\ninstantiation variable\n<br>\nclause\n<br>\nmethod\n<br>\ninstance-vars\n<br>\nClass variables\n<br>\n<br></p>\n<p>Anytime you change the value of something use a exclamation point to signify you are not doing functional programming.</p>\n<h5>L19</h5>\n<p>OOP implements inheritance through delegation (assigning to something else).\n<br>\n<br>\nChild looks for the methods and if it can’t find it the message is sent to the parent.\n<br>\n<br>\ndefault-method: what to do when the parent can’t handle the message.\n<br>\n<br>\ninitialize: method only used once to setup the class\n<br>\n<br>\ndispatch procedure: takes message and returns a method.</p>\n<h5>L20</h5>\n<p>OOP: With every object you have the procedures that work on it.\n<br>\n<br></p>\n<p>Polymorphism: Ability to work with other types in the sending op messages.\n<br>\n<br></p>\n<p>Garbage collection: automatic storage management.</p>\n<br>\n<h5>L21</h5>\n<p>global variables: available to anyone\n<br>\nclass variables: available to that class\n<br>\ninstance variables available to that instance\n<br></p>\n<p>Persistent local state variables.\nLambda inside a let creates local state variables.\n<br>\n<br></p>\n<p>Can wrap lambda in parenthesis to invoke it after creating it.</p>\n<br>\n<br>\n<p>Substitution model (eval exp):\n<br>\nEval all sub expressions\n<br>\napply procedure to arg list\n<br>\nsubstitute args for params in body\n<br>\neval modified body\n<br>\n<br></p>\n<p>Environment model (eval exp in env):\n<br>\nEval all sub expressions.\n<br>\napply procedure to arg list\n<br>\nmake an env with params bound to args\n<br>\nEval body in new env.\n<br></p>\n<h5>L22</h5>\n<p>Environemnt:\n<br>\nframe\n<br>\nmaps variables to values\n<br>\npointer to “enclosing environment”\n<br>\nAll evals are done in a environment.\n<br>\n<br></p>\n<p>Creates a new environment when you invoke a procedure.\n<br></p>\n<p>Can create a pointer to another environment to inherit those variables.\n<br>\n<br>\n1.) look in current env, if found return value\n<br>\n2.) look in parent env, if found return value\n<br>\n3.) if not in parent env returne UNBOUND VARIABLE error.</p>\n<h5>L23</h5>\n<h4>LABS</h4>\n<h5>4A</h5>\n<h5>4B</h5>\n<h4>READINGS</h4>\n<h5>3.1</h5>\n<h5>3.2</h5>"}