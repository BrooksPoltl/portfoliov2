{"expireTime":9007200843257983000,"key":"transformer-remark-markdown-html-a8410dd005b1ee392fc4f81bcd9993b7-gatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypants-","val":"<h4>LECTURES</h4>\n<h5>L14</h5>\n<p>2 types of expressions:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                 expr\n    _______________|___________________    \n    |                                 |\n    atomic                           list\n    ___|__________                     |\n    |            |            _______________________       \nself-eval    variables        procedures special-forms</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    (define (eval exp)\n    (cond ((self-evaluating? exp) exp)\n    ((symbol? exp) (look-up-global-value exp))\n    ((special-form? exp) (do-special-form exp))\n    (else (apply (eval (car exp))\n    (map eval (cdr exp)) ))))</code></pre></div>\n<p>Above is the eval function for an interpreter in Scheme. Notice it attempts to determine the type of expression then has a function to handle them. If it is a list it recursively calls eval to break the list into primitives.\n<br>\n<br></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    (define (apply proc args)\n        (if (primitive? proc)\n            (do-magic proc args)\n            (eval (substitute (body proc) (formals proc) args))))</code></pre></div>\n<p>apply takes a procedure and a list of arguments. In the else of <code class=\"language-text\">eval</code> apply gets the first argument which will always the procedure call, and then it maps the arguments.\n<br>\n<br></p>\n<p>If the procedure is a primitive it gets handled at the machine language level.</p>\n<br>\n<br>\n<p>If the procedure is created by a lambda,\nit has formal parameters and a body.\n<br>\n<br>\nScheme uses environmental model of evaluation, but we are building a substitution model interpreter right now.\nSubstitution works for functional programming, but not all paradigms.\n<br>\n<br></p>\n<h5>L15</h5>\n<p>Why use a scheme interpreter to build a new one?\n<br>\n<br>\nHelps understand model of evaluation\n<br>\nExperiment with modifications to scheme\n<br>\nMost of the original interpreter is written in scheme.\n<br>\nConveys a big concept in cs which is universality.\n<br>\n<br></p>\n<p>universality is the concept of one machine that can run a large breadth of functions.\n<br>\n<br>\nApplicative: argument values\n<br>\nNormal: argument expressions\n<br></p>\n<p>Read: takes the input and turns it into box pointer diagrams.\n<br>\nQuote: takes cadr of the next expression.\n<br></p>\n<h5>L16</h5>\n<p>concepts:\n<br>\ntype tagging\n<br>\ndata directed programming\n<br>\nmessage passing\n<br></p>\n<p>type tagging: car is the symbol, cdr is the arguments.\n<br></p>\n<p>data directed programming: write one operation that does everything.\n<br>\nNot functional programming if you call the same function and get different results.\n<br></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(get &#39;brian &#39;address)\n; #f\n(put &#39;brian &#39;address &#39;(781 Soda))\n; ok\n(get &#39;brian &#39;address)\n; (781 soda)</code></pre></div>\n<h5>L17</h5>\n<h5>L38</h5>\n<h5>L39</h5>\n<h4>LAB</h4>\n<h5>lab 3</h5>\n<h4>READINGS</h4>\n<h5>2.4</h5>\n<h5>2.5</h5>"}