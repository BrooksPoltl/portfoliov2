{"expireTime":9007200869000559000,"key":"transformer-remark-markdown-html-74ba8ad1da5e58e485ac4a5edb68285d-gatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypants-","val":"<p>This article is a part of a series where I go through <a href=\"https://teachyourselfcs.com/\">teachyourselfcs</a>.\nIf you would like to start at the beginning start <a href=\"https://bpp.dev/articles/teachyourselfcs/programming/00-getting-started/\">here</a>.</p>\n<h2>INTRO</h2>\n<p>I will be following the Summer 2010 <a href=\"http://inst.eecs.berkeley.edu/~cs61a/su10/index.html\">Calendar</a>\nso each week will consist of 4 lectures and 2 labs.</p>\n<h2>LECTURES</h2>\n<h3>L01</h3>\n<h4>Mathmatical Operations</h4>\n<p>Class starts by going over some sytax for Scheme. Most languages do simple operations the same way we learned in grade school (infix notation):\n<br><code class=\"language-text\">2 + 2 + 3</code><br>\nScheme uses a different syntax where the operator is always on the left (prefix notation) and you can add as many numbers as you would like:\n<br><code class=\"language-text\">(+ 2 2 3)</code><br>\nNow lets say we want to do something like: <br><code class=\"language-text\">2 + 2 + 3 - 4</code><br>\nIn Scheme you can simply nest operators:\n<br><code class=\"language-text\">(- (+ 2 2 3) 4)</code><br>\n<br>\nWhen you first see this it looks way more complicated, but what is happening under the hood makes it a lot clearer.\n<br>\nScheme takes the arguments and then computes the expressions of the arguments until it gets down to a primitive value.\n<code class=\"language-text\">(+ 2 2 3)</code> is a expression and not a primitive value, so it calls <code class=\"language-text\">(+ 2 2 3)</code>. The left argument of the <code class=\"language-text\">-</code> is now 7 and both arguments are primitive values, meaning it can calculate the <code class=\"language-text\">-</code> to get 3.</p>\n<h4>Define</h4>\n<p><code class=\"language-text\">define</code> is an interesting keyword. It can be used to create functions:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(define (square x)\n    (* x x))</code></pre></div>\n<br>\n<p>The syntax is very different from other languages, but try to think of <code class=\"language-text\">define</code> as a function itself.\n<br>\n<br>\nDefine’s first parameter takes in a symbol (square) as it’s first argument that will be the name of the procedure. The rest of the parameters are parameters for the body in this case <code class=\"language-text\">x</code>.\n<br>\n<br>\nThe second parameter that <code class=\"language-text\">define</code> takes in is the body that the procedure will call <code class=\"language-text\">(* x x)</code>.</p>\n<br>\n<p>Define can also be used to store constants:\n<br>\n<code class=\"language-text\">(define pi 3.14159)</code>\n<br></p>\n<p>This is the same thing as above but used in a different way. Since 3.14159 is a primitive no expression needs to be evaluated for the second parameter.</p>\n<h4>Conditionals</h4>\n<p>Here is the first example of a program we see in class:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(define (plural wd)\n\t(if (equal? (last wd) &#39;y)\n\t(word (bl wd) &#39;ies)\n\t(word wd &#39;s)))</code></pre></div>\n<br>\n<p>As you’ve probably already guessed, <code class=\"language-text\">if</code> is a function.\n<br>\n<br>\nThe first parameter is the test case for example if we input fly <code class=\"language-text\">(equal? (last wd) &#39;y)</code> would be true, because fly ends in y.\n<br>\n<br>\nThe third parameter <code class=\"language-text\">if</code> takes in is the expression if the test case is true.\n<br>\n<br>\nThe third parameter <code class=\"language-text\">if</code> takes in is the expression if the test case is false.\n<br>\n<br>\nAlso worth noting that names that return a boolean add a <code class=\"language-text\">?</code> to the end to show that the primitive returned is true or false. Like how equal is <code class=\"language-text\">equal?</code> in the code block above.</p>\n<h3>L02</h3>\n<h4>Recursion</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(define (pigl wd)\n\t(if (pl-done? wd)\n\t\t(word wd &#39;ay)\n\t\t(pigl (word (bf wd) (first wd)))))\n\n(define (pl-done? wd)\n\t(vowel? (first wd)))\n\n(define (vowel? letter)\n\t(member? letter &#39;(a e i o u)))</code></pre></div>\n<br>\n<p>Recursion is when a procedures calls the same procedure that it is writing. Without a test case this will go on infinitely, but a recursive function continues to do the body of the procedure until it is told to end.\n<br>\n<br>\nNotice in the above example from lecture the function calls pigl until <code class=\"language-text\">pl-done</code> is equal to true.\n<br>\n<br>\nLets say <code class=\"language-text\">pigl</code> gets called with <code class=\"language-text\">scheme</code>.\nThe conditional checks <code class=\"language-text\">pl-done</code> which checks the first letter in the word to see if it is a vowel. Since <code class=\"language-text\">pl-done</code> is false because <code class=\"language-text\">s</code> isn’t a vowel it calls <code class=\"language-text\">pigl</code> again with the argument <code class=\"language-text\">chemes</code>. This is because <code class=\"language-text\">word</code> takes the arguments <code class=\"language-text\">cheme</code> and <code class=\"language-text\">s</code> and adds them together. <code class=\"language-text\">pigl</code> gets called repeatedly until\nit is called with a vowel as the first letter. When the first letter is a vowel the expression <code class=\"language-text\">(word wd &#39;ay)</code> is ran and the result is a primitive which means the procedure stops.</p>\n<h4>Abstraction</h4>\n<p>Big Picture:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Application                   (highest)\n------------------------------\nHigh level language (Scheme)\n------------------------------\nlow level language  ( C )\n------------------------------\nmachine language/ architecture\n------------------------------\nlogic gates\n------------------------------\ntransistors\n------------------------------\nquantum physics                 (lowest)\n------------------------------</code></pre></div>\n<br>\n<p>Abstraction is the layering of pieces on top of eachother. Little pieces are put together to form a layer that can be referenced as a whole.</p>\n<h4>Functional Programming</h4>\n<p>With the introduction of multi-core processers, parallelism has helped functional programming make a comeback. If everything is a function you won’t run into race conditions created by dependencies.</p>\n<h4>Function vs. Procedure</h4>\n<p>Two functions are the same if they give the same output with given inputs.\n<br>\n<br>\nA procedure is a sequence of steps for computing a function.\n<br><br>\nTherefore <code class=\"language-text\">2x + 6</code> and <code class=\"language-text\">2(x + 3)</code> are the same function but different procedures.\n<br></p>\n<h4>Cond</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(define (buzz n)\n    (cond ((equal? (remainder n 7) 0) &#39;buzz)\n    ((member? 7 n) &#39;buzz)\n    (else n)))</code></pre></div>\n<br>\n<br>\n<p><code class=\"language-text\">cond</code> allows for multiple test cases, and will return\nthe first clause that is true.\n<br>\n<br>\nLets try <code class=\"language-text\">14</code>. Since <code class=\"language-text\">14 / 7</code> has a remainder of <code class=\"language-text\">0</code> the first clause is met and returns <code class=\"language-text\">buzz</code>.\n<br>\n<br>\nNow Lets try <code class=\"language-text\">17</code>. The first clause is not met, and therefore goes onto the next clause. <code class=\"language-text\">17</code> does have a 7 inside of it so <code class=\"language-text\">buzz</code> is returned.\n<br>\n<br>\nNow lets try <code class=\"language-text\">15</code>. The remainder is <code class=\"language-text\">1</code> so the first clause is not met, and <code class=\"language-text\">15</code> does not have a <code class=\"language-text\">7</code> inside of it so the catch all <code class=\"language-text\">else</code> keyword returns the number <code class=\"language-text\">15</code>.\n<br>\n<br>\nImportant to note:\n<br>\nIf a <code class=\"language-text\">cond</code> does not have an <code class=\"language-text\">else</code> statement it will return <code class=\"language-text\">unspecified</code>, which can be different depending on interpreted, so always have an else statement.</p>\n<h4>Applicative Order vs Normal Order</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(def (f a b) (+ (g a) b))\n(def (g x) (* 3 x))\n\n(f (+ 2 3) (- 15 6))</code></pre></div>\n<p>Applicative Order:\n<br>\nevaluates the sub expressions until they are primitive values, then passes the primitive results back up to the parent function.\n<br>\n<code class=\"language-text\">(f (+ 2 3) (- 15 6))</code>\n<br>\n<code class=\"language-text\">2 + 3</code> and <code class=\"language-text\">15 - 6</code> will be evaluated before the outside <code class=\"language-text\">f</code> is evaluated. Then <code class=\"language-text\">f</code> will be called with <code class=\"language-text\">(f 5 9)</code>.\n<br>\nNormal Order:\n<br>\nevaluates the outsides first, but instead of passing primitive values it passes the expressions.\n<br>\n<code class=\"language-text\">(f (+ 2 3) (- 15 6))</code> turns into <code class=\"language-text\">(+ (g (+ 2 3)) (- 15 6))</code>\n<br>\nNow <code class=\"language-text\">f</code> is done and the next expression can be evaluated.</p>\n<p>Possible Problem:\n<br></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(def (zero z) (- x x))</code></pre></div>\n<p>applicative</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(zero (random 10)) ---&gt;\n(random 10) ==&gt; 8\n(zero 8) ---&gt;\n(- 8 8) ==&gt; 0\n0</code></pre></div>\n<p>normal</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(zero (random 10)) ---&gt;\n(+ (random 10) (random 10)) ==&gt;\n    (random 10) ==&gt; 8\n    (random 10) ==&gt; 1\n(- 8 1) ==&gt; 7\n7</code></pre></div>\n<br>\n<br>\n<p>Since the <code class=\"language-text\">(random 10)</code> is split into 2 different function alls in normal order you get different results.</p>\n<h3>L03</h3>\n<h4>Data vs Procedures</h4>\n<p>Data is like a noun. Procedures are like verbs.\n<br>\n<br>\nCapitalization does not matter in scheme.\nAble to take in functions as arguments.\n<code class=\"language-text\">se</code> is the function for creating sentences.</p>\n<h4>Lambda</h4>\n<p>The thing that makes a function.\nA thing that creates and can call a function without having to be named.\n<br>\n<br>\nPRED: short for predicate, predicate is a function whose range is a boolean (true or false).\nEvery procedure has a lambda hidden inside of it.</p>\n<h3>L04</h3>\n<p>Using lambdas for control using procedures as data.\nKeep decides whether to keep data or not.</p>\n<h4>first class datatype</h4>\n<p>Rule of Thumb:\n<br>\nThey can be stored as a variable.\n<br>\nThey can be stored inside a data type like a list.\n<br>\nYou can return function to make other functions.\n<br>\n<code class=\"language-text\">(let bindings body)</code>\nBinding is a name: value expression.<br>\nBindings can’t reference eachother during declaration because of applicative order.\n<br>\n<code class=\"language-text\">let*</code> allows you to reference other bindings during declaration by nesting the <code class=\"language-text\">let</code>s.\n<br>\nWant to keep as many variables local as possible.</p>\n<h2>LABS</h2>\n<h3>Lab 1A</h3>\n<p>The first problem for the lab was to modify the <code class=\"language-text\">plural</code> program to handle a word ending in y, but has a vowel in front of it (boy).</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(define (plural wd)\n\t(if (equal? (last wd) &#39;y)\n\t\t(if (vowel? (last (bl wd)))\n\t\t(word wd &#39;s)\n\t\t(word (bl wd) &#39;ies))\n\t(word wd &#39;s)))\n\n(define (vowel? letter)\n\t(member? letter &#39;(a e i o u)))</code></pre></div>\n<br>\n<p>I handled this by adding a conditional that checks for the second to last letter.\n<br>\n<br>\nThe second assgnment was:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Define a procedure that takes three numbers as arguments and returns the sum of\nthe squares of the two larger numbers.</code></pre></div>\n<p>My Solution:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(define (twoLargerSums a b c)\n    (if (&gt;= a b)\n        (if (&gt;= b c)\n            (+ (square a) (square b))\n            (+ (square a) (square c)))\n        (if (&gt;= a c)\n            (+ (square a) (square b))\n            (+ (square b) (square c))))\n)\n\n(define (square x)\n(* x x))</code></pre></div>\n<br>\n<br>\n<h4>Lab 1B</h4>\n<p>Solution for #3 on lab:\n<br></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(define (substitute sent old new)\n    (if (equal? sent &#39;())\n        &#39;()\n        (se (replace (first sent) old new) (substitute (bf sent) old new))))\n\n(define (replace wd old new)\n    (if (equal? wd old)\n        new\n        wd)\n)</code></pre></div>\n<br>\n<br>\n<p>Note to self, don’t copy and paste function calls to check if your code is right because there might be special characters in there :P.\n<br>\n<br>\nThe replace function here takes in the current word and checks to see if the word should be replaced, then it returns what the word should be.\nSubstitute is a recursive function that iterates the sentence and returns the sentence with the replacements.</p>\n<h2>READINGS</h2>\n<h5>1.1 The Elements of Programming</h5>\n<p>The section starts off saying that there are 3 mechanisms that languages utilize to simplify complex ideas:\n<br>\nprimitive expressions: simplest entities within a language.\n<br>\n<br>\nmeans of combination: The ability to combine simple entities.\n<br>\n<br>\nmeans of abstraction: The ability to name and manipulate combined elements.\n<br>\n<br>\nBreaking down a compound expression:\n<br>\ncombination: <code class=\"language-text\">(+ 137 349)</code>\n<br>\noperator: <code class=\"language-text\">+</code>\n<br>\noperands: <code class=\"language-text\">137</code> <code class=\"language-text\">349</code>\n<br>\n<br>\nThe interpreter runs in a “read-eval-print” loop. That is why it is not necessary to print stuff out like in other languages.\n<br>\n<br>\nEnvironment: The name-object pairs the interpreter keeps in memory.\n<br>\n<br></p>\n<p>Compound Procedures can be used to build on top of other Compound Procedures:\n<br></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(define (sum-of-squares x y)\n(+ (square x) (square y))</code></pre></div>\n<br>\n<p>Compound Procedure: procedure that you make out of other procedures.</p>\n<p>Primitive Procedure: procedure built into the language ex: <code class=\"language-text\">+</code>\n<br>\n<br>\nBoth are used exactly the same.\n<br>\n<br>\nWhen writing programs it is important to write modular code that doesn’t care how the other things are computed, only what is computed. This is known as a Black-Box abstraction.\n<br></p>\n<p>Lisp allows for block structure so you can nest a define in another define, and only the parent will have access to the nested define.\n<br>\nLisp also allows the sub define functions to have access to parameters in the parents scope. This is called lexical scoping.\n<br></p>\n<h5>1.2 Procedures and the processes they generate</h5>\n<h6>Linear Recursion vs linear interative</h6>\n<p>Recursive calls itself, interative uses a helper iterator function to loop through the possibilities.\n<br>\n<br>\nTail-recursive: an iterative process in constant space.\n<br>\n<br>\nTree-recursive: think fibonacci where it uses recursion multiple times.\nTree recursive procedures are easy to identify, but not very efficient. It is possible one day a “smart compiler” could find these procedures and make them efficient.</p>\n<h5>1.3 Formulating Abstractions with Higher Order Procedures</h5>\n<p>Sigma Notation: The sum of numbers between A and B.\nThis can be abstracted to create a procedure that handles all needs for doing a procedure to calculate a sum.\n<br>\n<br>\nArguments for a Summation function:\n<br>\n<br>\nTerm: Procedure for the sum.\n<br>\na: start point\n<br>\nb: end point\n<br>\nnext: The increment function ex: + 1 + 2 + 3\n<br>\n<br></p>\n<p>You can use binary search like logic to find points within a function. By splitting the length repeatedly then checking accuracy you can continually get closer to the point you are looking for in the function. The calculated runtime for these functions are:\n<br>\n<br></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">L = length of the functions start to end points\nT = tolerance, the distance from the given point that will return a result\nruntime:\nlog(L/T)</code></pre></div>\n<p>Think of L/T as the possibilties between the two points.</p>"}